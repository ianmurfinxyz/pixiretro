- need to take into account different color modes when drawing sprites - at min always take
the color from the sprite resource independent of the color mode.

how to handle the font loading?

  - bitmap font generator can generate the image with the RGB channels all white (255) for the entire
    image and the alpha channel being 255 for glyph pixels and 0 for non-glyph pixels (empty space).
    I can then load this format into a sprite instance (seperating each glyph into their own sprite
    or I can store the sheet in the font and have the draw text function just use the sheet; the
    latter way will prob be better as it will mean fewer vector instances and therefore fewer
    small allocations, less fragmentation and less allocation time)
  - since I use an alpha value of 0 as the key for non-drawn pixels those empty space pixels
    when copied to a screen will not be drawn event though the RGB channels will be set to 255 
    on the screen (or I could just not copy the pixels to the screen but this would require checks
    on every pixel)
  - in color mode rgb the text would be drawn white since that is the color of each pixel in the
    bitmap, in color mode bitmaps, all pixels with alpha channel values != alpha key (i.e. 0)
    will adopt the bitmap color. This will allow me to draw fonts in any color.
  - this method will also allow me to use the banded color modes when drawing text. (side note
    that in si the ui doesnt use color banding, thus the ui layer will want to be in rgb mode 
    while the stage layer will want to be in banding mode).
  - can use tiny xml to load font data and data for each glyph then use bmpimage to load the
    glyph image (will need to convert glyph image to a bmp 32bit RGBA with gimp as bitmap font
    generator prog only exports png). The xml file contains the offset, sizes and advances etc
    I need to space all glyphs.
  - Bitmap font generator is doing a really bad job of generating a png for a small 8px font, 
    thus I think I will need to make the image myself and set the data in the xml file myself
    for the font. This will be the base little font used in the game. May be able to use 
    the font generator for larger fonts that it wont butcher, thus should copy the xml format
    so I can load both custom hand written xml font files and the ones generated by the font
    generator program.


    NEXT STEP THEN:
      HAND MAKE MY FONT IMAGE AND THE XML
      IMPLEMENT THE FONT LOADER AND FONT RENDERER IN GFX
      UPDATE THE BITMAP CLASS TO STORE THE WIDTH HEIGHT DATA IN A SIZE VECTOR2I TO BRING INLINE 
      WITH CONVENTIONS USED ELSEWHERE IN THE ENGINE CODE BASE.

  - had another idea to support animations - should change ResourceKey_t for sprites to being
    for sprite sheets and then in the function to drawSprite should include a frame parameter
    like:
        drawSprite(Vector2i position, TilesetID setid, int frame, Layer layer)
                                          ^
                                          |
                                          tileset is a better name than sprite sheet.

                                              or how about spriteset

                                              SpritesetID    <-- yh I like this even better
                                                                 since they are not really tiles
                                                                 but frames in a set, the set
                                                                 can be any set though.

    and create an xml file for the sheet which like for fonts contains meta data for each frame
    in the sheet as well as for the sheet itself, so the filename for the image, the number of
    frames in the sheet, and for the frames, the positions in the image and the frame number.

    This will make loading sprites analagous to loading fonts in that both assets use an xml file
    for meta data and an associated bmp file for the pixel data.

    This would make it easier to implement large animation sets such as needed if I were to
    implement a game like galaga which uses frames for different rotation states.

    would prob still hardcode the expected number of frames in each sheet and what each frame
    corresponds to so would have to match up the data in the xml file and the bmp file with the
    hardcoded expectations in the game code.

  - can also get rid of the sprite class and just have a tileset class which contains the pixel
    data stored in a bmpimage instance (bmpimage and sprite are basically exactly the same in 
    terms of member data), and then store the metadata for the frames within the tileset class.

  
DONE: 26th jan
  - implemented sprite sheets and their loader

TODO
  - refactor draw sprite to use the sprite sheets instead (will need to pass a frame)
  - compile, debug and test new bmpimage and gfx code
  - implement font loading and rendering
  - compile and test

TODO
  - thoroughly test the asset loaders by trying to break them - will want to verify font data
    by checking all glyph coordinates are within the bmp file to avoid later seg faults. Keep
    varying the errors in the xml file to see how my loader handles them. Want to handle them
    gracefully and avoid crashes.

  - handle the different color modes when redering and implement further rendering functions.

TODO - 29th jan
  - IT RUNS LIKE SHIT!! NEED TO IMPROVE THE PERFORMANCE OF THE RENDERING. THIS WILL NOT DO!
  - After timing some of the code it is the glClear call which is taking around 15-20ms to return.
    This thread explains why this happens:
      https://stackoverflow.com/questions/29551516/glclear-takes-too-long-android-opengl-es-2
    Basically my draw calls are too expensive. The CPU is able to issue the calls far faster than
    the GPU is able to render them, thus the glClear call is running some sync method to stall
    the CPU until the GPU can catch up. Solution is clearly to reduce the demand on the GPU.

    Good news is that my text rendering function was not the problem thus that doesn't need 
    optimising.

    note: this likely also explains why the profiling tools I was using (gprof and valgrind) were 
    not very helpful and did not reveal this problem. They were telling me it was the text rendering 
    function that was taking all the time. This is likely that it was taking all the CPU time (the 
    most expensive function run on the CPU) and the profilers were not measuring the time the CPU 
    was waiting for the GPU.
